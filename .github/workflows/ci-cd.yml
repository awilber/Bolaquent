name: Bolaquent CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.9", "3.10", "3.11"]

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov
    
    - name: Lint with flake8
      run: |
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: Format check with black
      run: |
        black --check --line-length=100 .
    
    # - name: Type check with mypy
    #   run: |
    #     mypy . --ignore-missing-imports
    
    # - name: Test with pytest
    #   run: |
    #     pytest --cov=. --cov-report=xml
    
    - name: Test Flask app imports
      run: |
        python -c "import app; print('‚úÖ Flask app imports successfully')"

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    
    - name: Create deployment package
      run: |
        mkdir -p deploy
        # Explicitly copy all necessary files and directories
        cp -r app.py config.py models.py requirements.txt requirements-prod.txt deploy/
        cp -r routes/ templates/ static/ docs/ deploy/
        cp -r *.py *.txt *.md deploy/ 2>/dev/null || true
        
        # Verify critical theme files are copied
        echo "üîç Verifying theme files in deployment package:"
        ls -la deploy/static/css/
        echo "üìÑ Checking themes.css header:"
        head -3 deploy/static/css/themes.css
        
        cd deploy
        # Don't install packages into deployment directory - use venv on server instead
        rm -rf .git .github __pycache__ *.pyc deploy
        
        # Final verification before zipping
        echo "üîç Final package contents:"
        find . -name "*.css" -o -name "*.js" | sort
        
        zip -r ../bolaquent-deploy.zip .
    
    - name: Upload deployment artifact
      uses: actions/upload-artifact@v4
      with:
        name: bolaquent-deploy
        path: bolaquent-deploy.zip

  deploy:
    needs: [test, build]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download deployment artifact
      uses: actions/download-artifact@v4
      with:
        name: bolaquent-deploy
    
    - name: Deploy via S3 and direct execution
      run: |
        # Upload deployment package to S3
        pip install awscli
        aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws configure set default.region us-east-1
        
        # Upload to S3 with timestamp
        DEPLOY_FILE="bolaquent-$(date +%Y%m%d-%H%M%S).zip"
        aws s3 cp bolaquent-deploy.zip s3://bolaquent-deployments/$DEPLOY_FILE
        
        # Create SSH key from secret and deploy
        echo "${{ secrets.EC2_PRIVATE_KEY }}" > private_key.pem
        chmod 600 private_key.pem
        
        # Deploy application using S3 download approach
        ssh -i private_key.pem -o StrictHostKeyChecking=no ec2-user@54.89.117.172 << EOF
          # Stop existing application and clear cache
          echo "üîÑ Stopping existing Flask applications..."
          pkill -f "python.*app.py" || true
          pkill -f "Flask" || true
          pkill -f "bolaquent" || true
          sleep 3
          
          # Kill processes using ports 5000 and 5001 with multiple methods
          echo "üî™ Killing processes on ports 5000 and 5001..."
          lsof -ti:5000 | xargs -r kill -9 || true
          lsof -ti:5001 | xargs -r kill -9 || true
          fuser -k 5000/tcp || true
          fuser -k 5001/tcp || true
          sleep 3
          
          # Force kill any remaining Flask processes with broader patterns
          ps aux | grep -E "(python.*app.py|Flask|venv.*python|bolaquent)" | grep -v grep | awk '{print \$2}' | xargs -r kill -9 || true 
          sleep 3
          
          # Final aggressive verification and cleanup
          echo "üîç Final verification and cleanup..."
          
          # If ports 5000/5001 are still in use, try one more aggressive cleanup
          PORTS_IN_USE=""
          if lsof -i:5000; then PORTS_IN_USE="$PORTS_IN_USE 5000"; fi
          if lsof -i:5001; then PORTS_IN_USE="$PORTS_IN_USE 5001"; fi
          
          if [ -n "$PORTS_IN_USE" ]; then
            echo "‚ö†Ô∏è Ports$PORTS_IN_USE still in use - final aggressive cleanup..."
            lsof -ti:5000 | xargs -r kill -9 || true
            lsof -ti:5001 | xargs -r kill -9 || true
            fuser -k 5000/tcp || true
            fuser -k 5001/tcp || true
            sleep 5
            
            # Check one more time
            STILL_IN_USE=""
            if lsof -i:5000; then STILL_IN_USE="$STILL_IN_USE 5000"; fi
            if lsof -i:5001; then STILL_IN_USE="$STILL_IN_USE 5001"; fi
            
            if [ -n "$STILL_IN_USE" ]; then
              echo "‚ö†Ô∏è Ports$STILL_IN_USE still in use - Flask will use port 5001 in production"
              lsof -i:5000 || true
              lsof -i:5001 || true
            else
              echo "‚úÖ All ports freed"
            fi
          else
            echo "‚úÖ Ports 5000 and 5001 are free"
          fi
          
          # Final process check
          if ps aux | grep -E "(python.*app.py|Flask)" | grep -v grep; then
            echo "‚ö†Ô∏è Some Flask processes still running - will be replaced"
            ps aux | grep -E "(python.*app.py|Flask)" | grep -v grep
          else
            echo "‚úÖ All Flask processes stopped"
          fi
          
          # Aggressive cleanup - remove all old versions
          rm -rf bolaquent-app* bolaquent-*.zip
          rm -rf __pycache__ .pytest_cache
          
          # Configure AWS credentials for S3 access
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set default.region us-east-1
          
          # Create fresh directory
          mkdir -p bolaquent-app
          cd bolaquent-app
          
          # Download latest deployment from S3
          echo "üì¶ Downloading deployment: $DEPLOY_FILE"
          aws s3 cp s3://bolaquent-deployments/$DEPLOY_FILE ./bolaquent-deploy.zip --region us-east-1
          unzip -o bolaquent-deploy.zip
          
          # Verify theme files are present
          echo "üîç Verifying theme files in deployed package:"
          ls -la static/css/
          echo "üìÑ Checking deployed themes.css header:"
          head -3 static/css/themes.css
          
          # Create virtual environment for clean package isolation
          echo "üêç Creating virtual environment..."
          python3 -m venv venv
          source venv/bin/activate
          
          # Install production dependencies only (Python 3.7 compatible)
          echo "üì¶ Installing Python dependencies..."
          pip install -r requirements-prod.txt
          echo "‚úÖ Dependencies installed"
          
          # Test Flask app can import before starting
          echo "üîç Testing Flask app import..."
          python -c "import app; print('‚úÖ Flask app imports successfully')" || echo "‚ùå Flask import failed"
          
          # Start application with enhanced logging and external access
          echo "üöÄ Starting Flask application..."
          export FLASK_ENV=production
          export PORT=5000
          export FLASK_HOST=0.0.0.0
          nohup ./venv/bin/python app.py > app.log 2>&1 &
          APP_PID=\$!
          echo \$APP_PID > app.pid
          echo "üìù Started Flask app with PID: \$APP_PID"
          
          # Wait and monitor startup
          echo "‚è≥ Waiting for Flask app to start..."
          sleep 10
          
          # Check if process is still running
          if ps -p \$APP_PID > /dev/null; then
            echo "‚úÖ Flask process \$APP_PID is running"
          else
            echo "‚ùå Flask process died - checking logs:"
            cat app.log
            exit 1
          fi
          
          # Test application endpoints (production uses port 5001)
          sleep 5
          echo "üîç Testing application endpoints..."
          curl -f http://localhost:5001/ && echo "‚úÖ App on 5001 (production)" || echo "‚ö†Ô∏è Port 5001 failed"
          curl -f http://localhost:5000/ && echo "‚úÖ App on 5000" || echo "‚ö†Ô∏è Port 5000 failed"
          curl -f http://localhost:5010/ && echo "‚úÖ App on 5010" || echo "‚ö†Ô∏è Port 5010 failed"
          
          # Verify deployed version has ProductLifecycle themes (check production port)
          echo "üîç Verifying deployed version has correct theme system:"
          curl -s http://localhost:5001/ | grep -E "(data-theme|theme-selector)" || echo "‚ö†Ô∏è Theme system not detected on 5001"
          curl -s http://localhost:5000/ | grep -E "(data-theme|theme-selector)" || echo "‚ö†Ô∏è Theme system not detected on 5000"
          curl -I http://localhost:5001/static/css/additional-themes.css || echo "‚ö†Ô∏è Additional themes file missing on 5001"
        EOF
        
        # Clean up
        rm private_key.pem
    
    - name: Verify deployment
      run: |
        echo "Deployment completed to EC2 instance i-0332d1b2863b08d95"
        echo "Application should be accessible at http://54.89.117.172/"
        
        # Wait for deployment to complete
        sleep 15
        
        # Test the deployment (check both ports)
        curl -I http://54.89.117.172/ || echo "‚ö†Ô∏è Checking nginx on port 80..."
        curl -I http://54.89.117.172:5001/ || echo "‚ö†Ô∏è Checking Flask on port 5001 (production)..."
        curl -I http://54.89.117.172:5000/ || echo "‚ö†Ô∏è Checking Flask on port 5000..."

  notify:
    needs: [deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Create deployment notification
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "‚úÖ Bolaquent deployed successfully to AWS"
          echo "üåê Live at: http://54.89.117.172/"
        else
          echo "‚ùå Deployment failed - check logs"
        fi